'''
Задание 2
'''


import timeit
def eratosfen_prime_numbers(limit, position):
    """
    Функция находит ряд простых чисел до i-ого элемента включительно и возвращает весь ряд чисел.
    Для нахождения используем алгоритм "Решето Эратосфена".
    """
    n = 2
    list_1 = list(range(limit + 1))

    list_1[1] = 0
    while n < limit:
        if list_1[n] != 0:
            m = n * 2
            while m < limit:
                list_1[m] = 0
                m += n
        n += 1
    return [p for p in list_1 if p != 0][position]


def non_eratosfen(position):
    """
     Функция сравнивает каждое число с числами от 2 до себя -1. Если находится делитель Число увеличивается на 1.
     Если же делителя нет, в новы массив добавляется это число.

     Без использования «Решета Эратосфена»
     """

    x = 0
    i = 2
    list1 = [2]
    while x < position: # до тех пор пока простое число по счету не стало равным искомому числу( последовательности)
        i +=1
        j = 2
        while j < i :
            if i % j == 0:
                break
            else:
                j +=1
        else:
            list1.append(i)
            x +=1
    return list1[position]

print(timeit.timeit('eratosfen_prime_numbers(99,5)', setup="from __main__ import eratosfen_prime_numbers", number=10))
print(timeit.timeit('non_eratosfen(5)', setup="from __main__ import non_eratosfen", number=10))


'''
Выводы: 
В случае Решета Эратосфена есть проблемы с знанием длины последовательности. По крайней мере в предоставленном решении. 
В моем решении длину последовательности чисел знать не надо.

Время выполнения в 1 случае сильно зависит именно от длинны введеного массива, даже если позиция простого числа будет 5 
но ряд будет состоят из 999.. чисел скорость будет плохой. 

Сложность O(n log(log n)). Является наиболее оптимальным с точки зрения скорости и если взять последовательность 
соответсвующую искомому элементу, то скорость будет наилучшей.
'''




